//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"

namespace Algorand.V2.Algod.Model
{
    using System = global::System;

    /// <summary>Account information at a given round.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/basics/userBalance.go : AccountData
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Account
    {
        /// <summary>the account public key</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>\[algo\] total number of MicroAlgos in the account</summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>specifies the amount of MicroAlgos in the account, without the pending rewards.</summary>
        [Newtonsoft.Json.JsonProperty("amount-without-pending-rewards", Required = Newtonsoft.Json.Required.Always)]
        public ulong AmountWithoutPendingRewards { get; set; }

        /// <summary>\[appl\] applications local data stored in this account.
        /// <br/>
        /// <br/>Note the raw object uses `map[int] -&gt; AppLocalState` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("apps-local-state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApplicationLocalState> AppsLocalState { get; set; }

        /// <summary>\[tsch\] stores the sum of all of the local schemas and global schemas in this account.
        /// <br/>
        /// <br/>Note: the raw account uses `StateSchema` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("apps-total-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema AppsTotalSchema { get; set; }

        /// <summary>\[teap\] the sum of all extra application program pages for this account.</summary>
        [Newtonsoft.Json.JsonProperty("apps-total-extra-pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AppsTotalExtraPages { get; set; }

        /// <summary>\[asset\] assets held by this account.
        /// <br/>
        /// <br/>Note the raw object uses `map[int] -&gt; AssetHolding` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("assets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AssetHolding> Assets { get; set; }

        /// <summary>\[appp\] parameters of applications created by this account including app global data.
        /// <br/>
        /// <br/>Note: the raw account uses `map[int] -&gt; AppParams` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("created-apps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Application> CreatedApps { get; set; }

        /// <summary>\[apar\] parameters of assets created by this account.
        /// <br/>
        /// <br/>Note: the raw account uses `map[int] -&gt; Asset` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("created-assets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Asset> CreatedAssets { get; set; }

        [Newtonsoft.Json.JsonProperty("participation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountParticipation Participation { get; set; }

        /// <summary>amount of MicroAlgos of pending rewards in this account.</summary>
        [Newtonsoft.Json.JsonProperty("pending-rewards", Required = Newtonsoft.Json.Required.Always)]
        public ulong PendingRewards { get; set; }

        /// <summary>\[ebase\] used as part of the rewards computation. Only applicable to accounts which are participating.</summary>
        [Newtonsoft.Json.JsonProperty("reward-base", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? RewardBase { get; set; }

        /// <summary>\[ern\] total rewards of MicroAlgos the account has received, including pending rewards.</summary>
        [Newtonsoft.Json.JsonProperty("rewards", Required = Newtonsoft.Json.Required.Always)]
        public ulong Rewards { get; set; }

        /// <summary>The round for which this information is relevant.</summary>
        [Newtonsoft.Json.JsonProperty("round", Required = Newtonsoft.Json.Required.Always)]
        public ulong Round { get; set; }

        /// <summary>\[onl\] delegation status of the account's MicroAlgos
        /// <br/>* Offline - indicates that the associated account is delegated.
        /// <br/>*  Online  - indicates that the associated account used as part of the delegation pool.
        /// <br/>*   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Status { get; set; }

        /// <summary>Indicates what type of signature is used by this account, must be one of:
        /// <br/>* sig
        /// <br/>* msig
        /// <br/>* lsig</summary>
        [Newtonsoft.Json.JsonProperty("sig-type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountSigType? SigType { get; set; }

        /// <summary>\[spend\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.</summary>
        [Newtonsoft.Json.JsonProperty("auth-addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthAddr { get; set; }


    }

    /// <summary>AccountParticipation describes the parameters used by this account in consensus protocol.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AccountParticipation
    {
        /// <summary>\[sel\] Selection public key (if any) currently registered for this round.</summary>
        [Newtonsoft.Json.JsonProperty("selection-participation-key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] SelectionParticipationKey { get; set; }

        /// <summary>\[voteFst\] First round for which this participation is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-first-valid", Required = Newtonsoft.Json.Required.Always)]
        public ulong VoteFirstValid { get; set; }

        /// <summary>\[voteKD\] Number of subkeys in each batch of participation keys.</summary>
        [Newtonsoft.Json.JsonProperty("vote-key-dilution", Required = Newtonsoft.Json.Required.Always)]
        public ulong VoteKeyDilution { get; set; }

        /// <summary>\[voteLst\] Last round for which this participation is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-last-valid", Required = Newtonsoft.Json.Required.Always)]
        public ulong VoteLastValid { get; set; }

        /// <summary>\[vote\] root participation public key (if any) currently registered for this round.</summary>
        [Newtonsoft.Json.JsonProperty("vote-participation-key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] VoteParticipationKey { get; set; }


    }

    /// <summary>Specifies both the unique identifier and the parameters for an asset</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Asset
    {
        /// <summary>unique asset identifier</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public int Index { get; set; }

        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AssetParams Params { get; set; } = new AssetParams();


    }

    /// <summary>Describes an asset held by an account.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/basics/userBalance.go : AssetHolding</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AssetHolding
    {
        /// <summary>\[a\] number of units held.</summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>Asset ID of the holding.</summary>
        [Newtonsoft.Json.JsonProperty("asset-id", Required = Newtonsoft.Json.Required.Always)]
        public ulong AssetId { get; set; }

        /// <summary>Address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.</summary>
        [Newtonsoft.Json.JsonProperty("creator")]
        public string Creator { get; set; }

        /// <summary>\[f\] whether or not the holding is frozen.</summary>
        [Newtonsoft.Json.JsonProperty("is-frozen", Required = Newtonsoft.Json.Required.Always)]
        public bool IsFrozen { get; set; }


    }

    /// <summary>AssetParams specifies the parameters for an asset.
    /// <br/>
    /// <br/>\[apar\] when part of an AssetConfig transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/asset.go : AssetParams</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AssetParams
    {
        /// <summary>\[c\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.</summary>
        [Newtonsoft.Json.JsonProperty("clawback", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Clawback { get; set; }

        /// <summary>The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.</summary>
        [Newtonsoft.Json.JsonProperty("creator")]
        public string Creator { get; set; }

        /// <summary>\[dc\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).</summary>
        [Newtonsoft.Json.JsonProperty("decimals", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 19)]
        public int Decimals { get; set; }

        /// <summary>\[df\] Whether holdings of this asset are frozen by default.</summary>
        [Newtonsoft.Json.JsonProperty("default-frozen", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DefaultFrozen { get; set; }

        /// <summary>\[f\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.</summary>
        [Newtonsoft.Json.JsonProperty("freeze", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Freeze { get; set; }

        /// <summary>\[m\] Address of account used to manage the keys of this asset and to destroy it.</summary>
        [Newtonsoft.Json.JsonProperty("manager", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manager { get; set; }

        /// <summary>\[am\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.</summary>
        [Newtonsoft.Json.JsonProperty("metadata-hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] MetadataHash { get; set; }

        /// <summary>\[an\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Base64 encoded name of this asset, as supplied by the creator.</summary>
        [Newtonsoft.Json.JsonProperty("name-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] NameB64 { get; set; }

        /// <summary>\[r\] Address of account holding reserve (non-minted) units of this asset.</summary>
        [Newtonsoft.Json.JsonProperty("reserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reserve { get; set; }

        /// <summary>\[t\] The total number of units of this asset.</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Always)]
        public ulong? Total { get; set; }

        /// <summary>\[un\] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("unit-name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UnitName { get; set; }

        /// <summary>Base64 encoded name of a unit of this asset, as supplied by the creator.</summary>
        [Newtonsoft.Json.JsonProperty("unit-name-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] UnitNameB64 { get; set; }

        /// <summary>\[au\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>Base64 encoded URL where more information about the asset can be retrieved.</summary>
        [Newtonsoft.Json.JsonProperty("url-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] UrlB64 { get; set; }


    }

    /// <summary>Specifies maximums on the number of each type that may be stored.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationStateSchema
    {
        /// <summary>\[nui\] num of uints.</summary>
        [Newtonsoft.Json.JsonProperty("num-uint", Required = Newtonsoft.Json.Required.Always)]
        public int NumUint { get; set; }

        /// <summary>\[nbs\] num of byte slices.</summary>
        [Newtonsoft.Json.JsonProperty("num-byte-slice", Required = Newtonsoft.Json.Required.Always)]
        public int NumByteSlice { get; set; }


    }

    /// <summary>Stores local state associated with an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationLocalState
    {
        /// <summary>The application which this local state is for.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public ulong Id { get; set; }

        /// <summary>\[hsch\] schema.</summary>
        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationStateSchema Schema { get; set; } = new ApplicationStateSchema();

        /// <summary>\[tkv\] storage.</summary>
        [Newtonsoft.Json.JsonProperty("key-value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TealKeyValueStore KeyValue { get; set; }


    }

    /// <summary>Represents a participation key used by the node.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ParticipationKey
    {
        /// <summary>The key's ParticipationID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>Address the key was generated for.</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>When registered, this is the first round it may be used.</summary>
        [Newtonsoft.Json.JsonProperty("effective-first-valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? EffectiveFirstValid { get; set; }

        /// <summary>When registered, this is the last round it may be used.</summary>
        [Newtonsoft.Json.JsonProperty("effective-last-valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? EffectiveLastValid { get; set; }

        /// <summary>Round when this key was last used to vote.</summary>
        [Newtonsoft.Json.JsonProperty("last-vote", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? LastVote { get; set; }

        /// <summary>Round when this key was last used to propose a block.</summary>
        [Newtonsoft.Json.JsonProperty("last-block-proposal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? LastBlockProposal { get; set; }

        /// <summary>Round when this key was last used to generate a state proof.</summary>
        [Newtonsoft.Json.JsonProperty("last-state-proof", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? LastStateProof { get; set; }

        /// <summary>Key information stored on the account.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AccountParticipation Key { get; set; } = new AccountParticipation();


    }

    /// <summary>Represents a key-value store for use in an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealKeyValueStore : System.Collections.ObjectModel.Collection<TealKeyValue>
    {

    }

    /// <summary>Represents a key-value pair in an application store.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealKeyValue
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TealValue Value { get; set; } = new TealValue();


    }

    /// <summary>Represents a TEAL value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealValue
    {
        /// <summary>\[tt\] value type. Value `1` refers to **bytes**, value `2` refers to **uint**</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        public int Type { get; set; }

        /// <summary>\[tb\] bytes value.</summary>
        [Newtonsoft.Json.JsonProperty("bytes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Bytes { get; set; }

        /// <summary>\[ui\] uint value.</summary>
        [Newtonsoft.Json.JsonProperty("uint", Required = Newtonsoft.Json.Required.Always)]
        public ulong Uint { get; set; }


    }

    /// <summary>Application state delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StateDelta : System.Collections.ObjectModel.Collection<EvalDeltaKeyValue>
    {

    }

    /// <summary>Application state delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AccountStateDelta
    {
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        [Newtonsoft.Json.JsonProperty("delta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StateDelta Delta { get; set; } = new StateDelta();


    }

    /// <summary>Key-value pairs for StateDelta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvalDeltaKeyValue
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EvalDelta Value { get; set; } = new EvalDelta();


    }

    /// <summary>Represents a TEAL value delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvalDelta
    {
        /// <summary>\[at\] delta action.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        public int Action { get; set; }

        /// <summary>\[bs\] bytes value.</summary>
        [Newtonsoft.Json.JsonProperty("bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bytes { get; set; }

        /// <summary>\[ui\] uint value.</summary>
        [Newtonsoft.Json.JsonProperty("uint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? Uint { get; set; }


    }

    /// <summary>Application index and its parameters</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Application
    {
        /// <summary>\[appidx\] application index.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public ulong Id { get; set; }

        /// <summary>\[appparams\] application parameters.</summary>
        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationParams Params { get; set; } = new ApplicationParams();


    }

    /// <summary>Stores the global information associated with an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationParams
    {
        /// <summary>The address that created this application. This is the address where the parameters and global state for this application can be found.</summary>
        [Newtonsoft.Json.JsonProperty("creator")]
        public string Creator { get; set; }

        /// <summary>\[approv\] approval program.</summary>
        [Newtonsoft.Json.JsonProperty("approval-program", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] ApprovalProgram { get; set; }

        /// <summary>\[clearp\] approval program.</summary>
        [Newtonsoft.Json.JsonProperty("clear-state-program", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] ClearStateProgram { get; set; }

        /// <summary>\[epp\] the amount of extra program pages available to this app.</summary>
        [Newtonsoft.Json.JsonProperty("extra-program-pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExtraProgramPages { get; set; }

        /// <summary>[\lsch\] local schema</summary>
        [Newtonsoft.Json.JsonProperty("local-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema LocalStateSchema { get; set; }

        /// <summary>[\gsch\] global schema</summary>
        [Newtonsoft.Json.JsonProperty("global-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema GlobalStateSchema { get; set; }

        /// <summary>[\gs\] global schema</summary>
        [Newtonsoft.Json.JsonProperty("global-state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TealKeyValueStore GlobalState { get; set; }


    }

    /// <summary>Stores the TEAL eval step data</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DryrunState
    {
        /// <summary>Line number</summary>
        [Newtonsoft.Json.JsonProperty("line", Required = Newtonsoft.Json.Required.Always)]
        public int Line { get; set; }

        /// <summary>Program counter</summary>
        [Newtonsoft.Json.JsonProperty("pc", Required = Newtonsoft.Json.Required.Always)]
        public int Pc { get; set; }

        [Newtonsoft.Json.JsonProperty("stack", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TealValue> Stack { get; set; } = new System.Collections.ObjectModel.Collection<TealValue>();

        [Newtonsoft.Json.JsonProperty("scratch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TealValue> Scratch { get; set; }

        /// <summary>Evaluation error if any</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }


    }

    /// <summary>DryrunTxnResult contains any LogicSig or ApplicationCall program debug information and state updates from a dryrun.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DryrunTxnResult
    {
        /// <summary>Disassembled program line by line.</summary>
        [Newtonsoft.Json.JsonProperty("disassembly", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Disassembly { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        [Newtonsoft.Json.JsonProperty("logic-sig-trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DryrunState> LogicSigTrace { get; set; }

        [Newtonsoft.Json.JsonProperty("logic-sig-messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> LogicSigMessages { get; set; }

        [Newtonsoft.Json.JsonProperty("app-call-trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DryrunState> AppCallTrace { get; set; }

        [Newtonsoft.Json.JsonProperty("app-call-messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AppCallMessages { get; set; }

        [Newtonsoft.Json.JsonProperty("global-delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StateDelta GlobalDelta { get; set; }

        [Newtonsoft.Json.JsonProperty("local-deltas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountStateDelta> LocalDeltas { get; set; }

        [Newtonsoft.Json.JsonProperty("logs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Logs { get; set; }

        /// <summary>Execution cost of app call transaction</summary>
        [Newtonsoft.Json.JsonProperty("cost", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Cost { get; set; }


    }

    /// <summary>An error response with optional data field.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ErrorResponse
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Data { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }


    }

    /// <summary>Request data type for dryrun endpoint. Given the Transactions and simulated ledger state upload, run TEAL scripts and return debugging information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DryrunRequest
    {
        [Newtonsoft.Json.JsonProperty("txns", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SignedTransaction> Txns { get; set; } = new System.Collections.ObjectModel.Collection<SignedTransaction>();

        [Newtonsoft.Json.JsonProperty("accounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Account> Accounts { get; set; } = new System.Collections.ObjectModel.Collection<Account>();

        [Newtonsoft.Json.JsonProperty("apps", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Application> Apps { get; set; } = new System.Collections.ObjectModel.Collection<Application>();

        /// <summary>ProtocolVersion specifies a specific version string to operate under, otherwise whatever the current protocol of the network this algod is running in.</summary>
        [Newtonsoft.Json.JsonProperty("protocol-version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProtocolVersion { get; set; }

        /// <summary>Round is available to some TEAL scripts. Defaults to the current round on the network this algod is attached to.</summary>
        [Newtonsoft.Json.JsonProperty("round", Required = Newtonsoft.Json.Required.Always)]
        public ulong Round { get; set; }

        /// <summary>LatestTimestamp is available to some TEAL scripts. Defaults to the latest confirmed timestamp this algod is attached to.</summary>
        [Newtonsoft.Json.JsonProperty("latest-timestamp", Required = Newtonsoft.Json.Required.Always)]
        public ulong LatestTimestamp { get; set; }

        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DryrunSource> Sources { get; set; } = new System.Collections.ObjectModel.Collection<DryrunSource>();


    }

    /// <summary>DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DryrunSource
    {
        /// <summary>FieldName is what kind of sources this is. If lsig then it goes into the transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the Approval Program or Clear State Program of application[this.AppIndex].</summary>
        [Newtonsoft.Json.JsonProperty("field-name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FieldName { get; set; }

        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Source { get; set; }

        [Newtonsoft.Json.JsonProperty("txn-index", Required = Newtonsoft.Json.Required.Always)]
        public int TxnIndex { get; set; }

        [Newtonsoft.Json.JsonProperty("app-index", Required = Newtonsoft.Json.Required.Always)]
        public ulong AppIndex { get; set; }


    }

    /// <summary>algod version information.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Version
    {
        [Newtonsoft.Json.JsonProperty("build", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BuildVersion Build { get; set; } = new BuildVersion();

        [Newtonsoft.Json.JsonProperty("genesis_hash_b64", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Genesis_hash_b64 { get; set; }

        [Newtonsoft.Json.JsonProperty("genesis_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Genesis_id { get; set; }

        [Newtonsoft.Json.JsonProperty("versions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Versions { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BuildVersion
    {
        [Newtonsoft.Json.JsonProperty("branch", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Branch { get; set; }

        [Newtonsoft.Json.JsonProperty("build_number", Required = Newtonsoft.Json.Required.Always)]
        public ulong Build_number { get; set; }

        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Channel { get; set; }

        [Newtonsoft.Json.JsonProperty("commit_hash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Commit_hash { get; set; }

        [Newtonsoft.Json.JsonProperty("major", Required = Newtonsoft.Json.Required.Always)]
        public ulong Major { get; set; }

        [Newtonsoft.Json.JsonProperty("minor", Required = Newtonsoft.Json.Required.Always)]
        public ulong Minor { get; set; }


    }

    /// <summary>Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PendingTransactionResponse
    {
        /// <summary>The asset index if the transaction was found and it created an asset.</summary>
        [Newtonsoft.Json.JsonProperty("asset-index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? AssetIndex { get; set; }

        /// <summary>The application index if the transaction was found and it created an application.</summary>
        [Newtonsoft.Json.JsonProperty("application-index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ApplicationIndex { get; set; }

        /// <summary>Rewards in microalgos applied to the close remainder to account.</summary>
        [Newtonsoft.Json.JsonProperty("close-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CloseRewards { get; set; }

        /// <summary>Closing amount for the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("closing-amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ClosingAmount { get; set; }

        /// <summary>The number of the asset's unit that were transferred to the close-to address.</summary>
        [Newtonsoft.Json.JsonProperty("asset-closing-amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? AssetClosingAmount { get; set; }

        /// <summary>The round where this transaction was confirmed, if present.</summary>
        [Newtonsoft.Json.JsonProperty("confirmed-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ConfirmedRound { get; set; }

        /// <summary>Indicates that the transaction was kicked out of this node's transaction pool (and specifies why that happened).  An empty string indicates the transaction wasn't kicked out of this node's txpool due to an error.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("pool-error", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PoolError { get; set; }

        /// <summary>Rewards in microalgos applied to the receiver account.</summary>
        [Newtonsoft.Json.JsonProperty("receiver-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ReceiverRewards { get; set; }

        /// <summary>Rewards in microalgos applied to the sender account.</summary>
        [Newtonsoft.Json.JsonProperty("sender-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? SenderRewards { get; set; }

        /// <summary>\[ld\] Local state key/value changes for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("local-state-delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountStateDelta> LocalStateDelta { get; set; }

        /// <summary>\[gd\] Global state key/value changes for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("global-state-delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StateDelta GlobalStateDelta { get; set; }

        /// <summary>\[lg\] Logs for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("logs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Logs { get; set; }

        /// <summary>Inner transactions produced by application execution.</summary>
        [Newtonsoft.Json.JsonProperty("inner-txns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PendingTransactionResponse> InnerTxns { get; set; }

        /// <summary>The raw signed transaction.</summary>
        [Newtonsoft.Json.JsonProperty("txn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Txn { get; set; } = new object();


    }

    /// <summary>Configures whether the response object is JSON or MessagePack encoded.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Format
    {
        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"msgpack")]
        Msgpack = 1,

    }

    /// <summary>PendingTransactions is an array of signed transactions exactly as they were submitted.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response
    {
        /// <summary>An array of signed transaction objects.</summary>
        [Newtonsoft.Json.JsonProperty("top-transactions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<object> TopTransactions { get; set; } = new System.Collections.ObjectModel.Collection<object>();

        /// <summary>Total number of transactions in the pool.</summary>
        [Newtonsoft.Json.JsonProperty("total-transactions", Required = Newtonsoft.Json.Required.Always)]
        public int TotalTransactions { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response2
    {
        /// <summary>Block header data.</summary>
        [Newtonsoft.Json.JsonProperty("block", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Block { get; set; } = new object();

        /// <summary>Optional certificate object. This is only included when the format is set to message pack.</summary>
        [Newtonsoft.Json.JsonProperty("cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Cert { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response3
    {
        /// <summary>Merkle proof of transaction membership.</summary>
        [Newtonsoft.Json.JsonProperty("proof", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Proof { get; set; }

        /// <summary>Hash of SignedTxnInBlock for verifying proof.</summary>
        [Newtonsoft.Json.JsonProperty("stibhash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Stibhash { get; set; }

        /// <summary>Index of the transaction in the block's payset.</summary>
        [Newtonsoft.Json.JsonProperty("idx", Required = Newtonsoft.Json.Required.Always)]
        public int Idx { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RegisterParticipationKeysResponse
    {
        /// <summary>encoding of the transaction hash.</summary>
        [Newtonsoft.Json.JsonProperty("txId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TxId { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static RegisterParticipationKeysResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<RegisterParticipationKeysResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    /// <summary>Supply represents the current supply of MicroAlgos in the system</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response4
    {
        /// <summary>Round</summary>
        [Newtonsoft.Json.JsonProperty("current_round", Required = Newtonsoft.Json.Required.Always)]
        public ulong Current_round { get; set; }

        /// <summary>OnlineMoney</summary>
        [Newtonsoft.Json.JsonProperty("online-money", Required = Newtonsoft.Json.Required.Always)]
        public ulong OnlineMoney { get; set; }

        /// <summary>TotalMoney</summary>
        [Newtonsoft.Json.JsonProperty("total-money", Required = Newtonsoft.Json.Required.Always)]
        public ulong TotalMoney { get; set; }


    }

    /// <summary>NodeStatus contains the information about a node status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NodeStatusResponse
    {
        /// <summary>CatchupTime in nanoseconds</summary>
        [Newtonsoft.Json.JsonProperty("catchup-time", Required = Newtonsoft.Json.Required.Always)]
        public ulong CatchupTime { get; set; }

        /// <summary>LastRound indicates the last round seen</summary>
        [Newtonsoft.Json.JsonProperty("last-round", Required = Newtonsoft.Json.Required.Always)]
        public ulong LastRound { get; set; }

        /// <summary>LastVersion indicates the last consensus version supported</summary>
        [Newtonsoft.Json.JsonProperty("last-version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LastVersion { get; set; }

        /// <summary>NextVersion of consensus protocol to use</summary>
        [Newtonsoft.Json.JsonProperty("next-version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NextVersion { get; set; }

        /// <summary>NextVersionRound is the round at which the next consensus version will apply</summary>
        [Newtonsoft.Json.JsonProperty("next-version-round", Required = Newtonsoft.Json.Required.Always)]
        public ulong NextVersionRound { get; set; }

        /// <summary>NextVersionSupported indicates whether the next consensus version is supported by this node</summary>
        [Newtonsoft.Json.JsonProperty("next-version-supported", Required = Newtonsoft.Json.Required.Always)]
        public bool NextVersionSupported { get; set; }

        /// <summary>StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress</summary>
        [Newtonsoft.Json.JsonProperty("stopped-at-unsupported-round", Required = Newtonsoft.Json.Required.Always)]
        public bool StoppedAtUnsupportedRound { get; set; }

        /// <summary>TimeSinceLastRound in nanoseconds</summary>
        [Newtonsoft.Json.JsonProperty("time-since-last-round", Required = Newtonsoft.Json.Required.Always)]
        public ulong TimeSinceLastRound { get; set; }

        /// <summary>The last catchpoint seen by the node</summary>
        [Newtonsoft.Json.JsonProperty("last-catchpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastCatchpoint { get; set; }

        /// <summary>The current catchpoint that is being caught up to</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Catchpoint { get; set; }

        /// <summary>The total number of accounts included in the current catchpoint</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint-total-accounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CatchpointTotalAccounts { get; set; }

        /// <summary>The number of accounts from the current catchpoint that have been processed so far as part of the catchup</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint-processed-accounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CatchpointProcessedAccounts { get; set; }

        /// <summary>The number of accounts from the current catchpoint that have been verified so far as part of the catchup</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint-verified-accounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CatchpointVerifiedAccounts { get; set; }

        /// <summary>The total number of blocks that are required to complete the current catchpoint catchup</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint-total-blocks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CatchpointTotalBlocks { get; set; }

        /// <summary>The number of blocks that have already been obtained by the node as part of the catchup</summary>
        [Newtonsoft.Json.JsonProperty("catchpoint-acquired-blocks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CatchpointAcquiredBlocks { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PostTransactionsResponse
    {
        /// <summary>encoding of the transaction hash.</summary>
        [Newtonsoft.Json.JsonProperty("txId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TxId { get; set; }


    }

    /// <summary>TransactionParams contains the parameters that help a client construct
    /// <br/>a new transaction.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionParametersResponse
    {
        /// <summary>ConsensusVersion indicates the consensus protocol version
        /// <br/>as of LastRound.</summary>
        [Newtonsoft.Json.JsonProperty("consensus-version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ConsensusVersion { get; set; }

        /// <summary>Fee is the suggested transaction fee
        /// <br/>Fee is in units of micro-Algos per byte.
        /// <br/>Fee may fall to zero but transactions must still have a fee of
        /// <br/>at least MinTxnFee for the current network protocol.</summary>
        [Newtonsoft.Json.JsonProperty("fee", Required = Newtonsoft.Json.Required.Always)]
        public ulong Fee { get; set; }

        /// <summary>GenesisHash is the hash of the genesis block.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-hash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] GenesisHash { get; set; }

        /// <summary>GenesisID is an ID listed in the genesis block.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GenesisId { get; set; }

        /// <summary>LastRound indicates the last round seen</summary>
        [Newtonsoft.Json.JsonProperty("last-round", Required = Newtonsoft.Json.Required.Always)]
        public ulong LastRound { get; set; }

        /// <summary>The minimum transaction fee (not per byte) required for the
        /// <br/>txn to validate for the current network protocol.</summary>
        [Newtonsoft.Json.JsonProperty("min-fee", Required = Newtonsoft.Json.Required.Always)]
        public ulong MinFee { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CompileResponse
    {
        /// <summary>base32 SHA512_256 of program bytes (Address style)</summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Hash { get; set; }

        /// <summary>base64 encoded program bytes</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Result { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DryrunResponse
    {
        [Newtonsoft.Json.JsonProperty("txns", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DryrunTxnResult> Txns { get; set; } = new System.Collections.ObjectModel.Collection<DryrunTxnResult>();

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Error { get; set; }

        /// <summary>Protocol version is the protocol version Dryrun was operated under.</summary>
        [Newtonsoft.Json.JsonProperty("protocol-version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProtocolVersion { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static DryrunResponse FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<DryrunResponse>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response10
    {
        /// <summary>Catchup start response string</summary>
        [Newtonsoft.Json.JsonProperty("catchup-message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CatchupMessage { get; set; }
        /// <summary>encoding of the participation id.</summary>
        [Newtonsoft.Json.JsonProperty("partId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PartId { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response11
    {
        /// <summary>Catchup start response string</summary>
        [Newtonsoft.Json.JsonProperty("catchup-message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CatchupMessage { get; set; }
        /// <summary>Detailed description of a participation key</summary>
        [Newtonsoft.Json.JsonProperty("participationKey", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ParticipationKey { get; set; }


    }

    /// <summary>An catchpoint start response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response12
    {
        /// <summary>Catchup start response string</summary>
        [Newtonsoft.Json.JsonProperty("catchup-message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CatchupMessage { get; set; }


    }

    /// <summary>An catchpoint abort response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response13
    {
        /// <summary>Catchup abort response string</summary>
        [Newtonsoft.Json.JsonProperty("catchup-message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CatchupMessage { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum AccountSigType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"sig")]
        Sig = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"msig")]
        Msig = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lsig")]
        Lsig = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this(data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this(data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108
#pragma warning restore 3016