//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"

namespace Algorand.V2.Indexer.Model
{
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;
    using System.IO;
    using System = global::System;


    /// <summary>Account information at a given round.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/basics/userBalance.go : AccountData
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Account
    {
        /// <summary>the account public key</summary>
        [Newtonsoft.Json.JsonProperty("address")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>\[algo\] total number of MicroAlgos in the account</summary>
        [Newtonsoft.Json.JsonProperty("amount")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>specifies the amount of MicroAlgos in the account, without the pending rewards.</summary>
        [Newtonsoft.Json.JsonProperty("amount-without-pending-rewards")]//)] //)] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong AmountWithoutPendingRewards { get; set; }

        /// <summary>\[appl\] applications local data stored in this account.
        /// <br/>
        /// <br/>Note the raw object uses `map[int] -&gt; AppLocalState` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("apps-local-state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApplicationLocalState> AppsLocalState { get; set; }

        /// <summary>\[tsch\] stores the sum of all of the local schemas and global schemas in this account.
        /// <br/>
        /// <br/>Note: the raw account uses `StateSchema` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("apps-total-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema AppsTotalSchema { get; set; }

        /// <summary>\[teap\] the sum of all extra application program pages for this account.</summary>
        [Newtonsoft.Json.JsonProperty("apps-total-extra-pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AppsTotalExtraPages { get; set; }

        /// <summary>\[asset\] assets held by this account.
        /// <br/>
        /// <br/>Note the raw object uses `map[int] -&gt; AssetHolding` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("assets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AssetHolding> Assets { get; set; }

        /// <summary>\[appp\] parameters of applications created by this account including app global data.
        /// <br/>
        /// <br/>Note: the raw account uses `map[int] -&gt; AppParams` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("created-apps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Application> CreatedApps { get; set; }

        /// <summary>\[apar\] parameters of assets created by this account.
        /// <br/>
        /// <br/>Note: the raw account uses `map[int] -&gt; Asset` for this type.</summary>
        [Newtonsoft.Json.JsonProperty("created-assets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Asset> CreatedAssets { get; set; }

        [Newtonsoft.Json.JsonProperty("participation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AccountParticipation Participation { get; set; }

        /// <summary>amount of MicroAlgos of pending rewards in this account.</summary>
        [Newtonsoft.Json.JsonProperty("pending-rewards")] //)] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong PendingRewards { get; set; }

        /// <summary>\[ebase\] used as part of the rewards computation. Only applicable to accounts which are participating.</summary>
        [Newtonsoft.Json.JsonProperty("reward-base", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RewardBase { get; set; }

        /// <summary>\[ern\] total rewards of MicroAlgos the account has received, including pending rewards.</summary>
        [Newtonsoft.Json.JsonProperty("rewards")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Rewards { get; set; }

        /// <summary>The round for which this information is relevant.</summary>
        [Newtonsoft.Json.JsonProperty("round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Round { get; set; }

        /// <summary>\[onl\] delegation status of the account's MicroAlgos
        /// <br/>* Offline - indicates that the associated account is delegated.
        /// <br/>*  Online  - indicates that the associated account used as part of the delegation pool.
        /// <br/>*   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.</summary>
        [Newtonsoft.Json.JsonProperty("status")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Status { get; set; }

        /// <summary>Indicates what type of signature is used by this account, must be one of:
        /// <br/>* sig
        /// <br/>* msig
        /// <br/>* lsig
        /// <br/>* or null if unknown</summary>
        [Newtonsoft.Json.JsonProperty("sig-type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountSigType? SigType { get; set; }

        /// <summary>\[spend\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.</summary>
        [Newtonsoft.Json.JsonProperty("auth-addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthAddr { get; set; }

        /// <summary>Whether or not this account is currently closed.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round during which this account first appeared in a transaction.</summary>
        [Newtonsoft.Json.JsonProperty("created-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CreatedAtRound { get; set; }

        /// <summary>Round during which this account was most recently closed.</summary>
        [Newtonsoft.Json.JsonProperty("closed-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ClosedAtRound { get; set; }


    }

    /// <summary>AccountParticipation describes the parameters used by this account in consensus protocol.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AccountParticipation
    {
        /// <summary>\[sel\] Selection public key (if any) currently registered for this round.</summary>
        [Newtonsoft.Json.JsonProperty("selection-participation-key")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] SelectionParticipationKey { get; set; }

        /// <summary>\[voteFst\] First round for which this participation is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-first-valid")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong VoteFirstValid { get; set; }

        /// <summary>\[voteKD\] Number of subkeys in each batch of participation keys.</summary>
        [Newtonsoft.Json.JsonProperty("vote-key-dilution")] //, Required = Newtonsoft.Json.Required.Always)]
        public int VoteKeyDilution { get; set; }

        /// <summary>\[voteLst\] Last round for which this participation is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-last-valid")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong VoteLastValid { get; set; }

        /// <summary>\[vote\] root participation public key (if any) currently registered for this round.</summary>
        [Newtonsoft.Json.JsonProperty("vote-participation-key")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] VoteParticipationKey { get; set; }


    }

    /// <summary>Specifies maximums on the number of each type that may be stored.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationStateSchema
    {
        /// <summary>\[nui\] num of uints.</summary>
        [Newtonsoft.Json.JsonProperty("num-uint")] //, Required = Newtonsoft.Json.Required.Always)]
        public int NumUint { get; set; }

        /// <summary>\[nbs\] num of byte slices.</summary>
        [Newtonsoft.Json.JsonProperty("num-byte-slice")] //, Required = Newtonsoft.Json.Required.Always)]
        public int NumByteSlice { get; set; }


    }

    /// <summary>Stores local state associated with an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationLocalState
    {
        /// <summary>The application which this local state is for.</summary>
        [Newtonsoft.Json.JsonProperty("id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Id { get; set; }

        /// <summary>Whether or not the application local state is currently deleted from its account.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round when the account opted into the application.</summary>
        [Newtonsoft.Json.JsonProperty("opted-in-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? OptedInAtRound { get; set; }

        /// <summary>Round when account closed out of the application.</summary>
        [Newtonsoft.Json.JsonProperty("closed-out-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? ClosedOutAtRound { get; set; }

        /// <summary>\[hsch\] schema.</summary>
        [Newtonsoft.Json.JsonProperty("schema")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationStateSchema Schema { get; set; } = new ApplicationStateSchema();

        /// <summary>\[tkv\] storage.</summary>
        [Newtonsoft.Json.JsonProperty("key-value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TealKeyValueStore KeyValue { get; set; }


    }

    /// <summary>Represents a key-value store for use in an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealKeyValueStore : System.Collections.ObjectModel.Collection<TealKeyValue>
    {

    }

    /// <summary>Represents a key-value pair in an application store.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealKeyValue
    {
        [Newtonsoft.Json.JsonProperty("key")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TealValue Value { get; set; } = new TealValue();


    }

    /// <summary>Represents a TEAL value.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TealValue
    {
        /// <summary>\[tt\] value type.</summary>
        [Newtonsoft.Json.JsonProperty("type")] //, Required = Newtonsoft.Json.Required.Always)]
        public int Type { get; set; }

        /// <summary>\[tb\] bytes value.</summary>
        [Newtonsoft.Json.JsonProperty("bytes")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Bytes { get; set; }

        /// <summary>\[ui\] uint value.</summary>
        [Newtonsoft.Json.JsonProperty("uint")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Uint { get; set; }


    }

    /// <summary>Application index and its parameters</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Application
    {
        /// <summary>\[appidx\] application index.</summary>
        [Newtonsoft.Json.JsonProperty("id")] //, Required = Newtonsoft.Json.Required.Always)]
        public int Id { get; set; }

        /// <summary>Whether or not this application is currently deleted.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round when this application was created.</summary>
        [Newtonsoft.Json.JsonProperty("created-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CreatedAtRound { get; set; }

        /// <summary>Round when this application was deleted.</summary>
        [Newtonsoft.Json.JsonProperty("deleted-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? DeletedAtRound { get; set; }

        /// <summary>\[appparams\] application parameters.</summary>
        [Newtonsoft.Json.JsonProperty("params")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ApplicationParams Params { get; set; } = new ApplicationParams();


    }

    /// <summary>Stores the global information associated with an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationParams
    {
        /// <summary>The address that created this application. This is the address where the parameters and global state for this application can be found.</summary>
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Creator { get; set; }

        /// <summary>\[approv\] approval program.</summary>
        [Newtonsoft.Json.JsonProperty("approval-program")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] ApprovalProgram { get; set; }

        /// <summary>\[clearp\] approval program.</summary>
        [Newtonsoft.Json.JsonProperty("clear-state-program")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] ClearStateProgram { get; set; }

        /// <summary>[\lsch\] local schema</summary>
        [Newtonsoft.Json.JsonProperty("local-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema LocalStateSchema { get; set; }

        /// <summary>[\lsch\] global schema</summary>
        [Newtonsoft.Json.JsonProperty("global-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApplicationStateSchema GlobalStateSchema { get; set; }

        /// <summary>[\gs\] global schema</summary>
        [Newtonsoft.Json.JsonProperty("global-state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TealKeyValueStore GlobalState { get; set; }

        /// <summary>\[epp\] the amount of extra program pages available to this app.</summary>
        [Newtonsoft.Json.JsonProperty("extra-program-pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ExtraProgramPages { get; set; }


    }

    /// <summary>Stores the global information associated with an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplicationLogData
    {
        /// <summary>Transaction ID</summary>
        [Newtonsoft.Json.JsonProperty("txid")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Txid { get; set; }

        /// <summary>\[lg\] Logs for the application being executed by the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("logs")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<byte[]> Logs { get; set; } = new System.Collections.ObjectModel.Collection<byte[]>();


    }

    /// <summary>Specifies both the unique identifier and the parameters for an asset</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Asset
    {
        /// <summary>unique asset identifier</summary>
        [Newtonsoft.Json.JsonProperty("index")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Index { get; set; }

        /// <summary>Whether or not this asset is currently deleted.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round during which this asset was created.</summary>
        [Newtonsoft.Json.JsonProperty("created-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CreatedAtRound { get; set; }

        /// <summary>Round during which this asset was destroyed.</summary>
        [Newtonsoft.Json.JsonProperty("destroyed-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? DestroyedAtRound { get; set; }

        [Newtonsoft.Json.JsonProperty("params")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public AssetParams Params { get; set; } = new AssetParams();


    }

    /// <summary>Describes an asset held by an account.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/basics/userBalance.go : AssetHolding</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AssetHolding
    {
        /// <summary>\[a\] number of units held.</summary>
        [Newtonsoft.Json.JsonProperty("amount")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>Asset ID of the holding.</summary>
        [Newtonsoft.Json.JsonProperty("asset-id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong AssetId { get; set; }

        /// <summary>Address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.</summary>
        [Newtonsoft.Json.JsonProperty("creator")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Creator { get; set; }

        /// <summary>\[f\] whether or not the holding is frozen.</summary>
        [Newtonsoft.Json.JsonProperty("is-frozen")] //, Required = Newtonsoft.Json.Required.Always)]
        public bool IsFrozen { get; set; }

        /// <summary>Whether or not the asset holding is currently deleted from its account.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round during which the account opted into this asset holding.</summary>
        [Newtonsoft.Json.JsonProperty("opted-in-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? OptedInAtRound { get; set; }

        /// <summary>Round during which the account opted out of this asset holding.</summary>
        [Newtonsoft.Json.JsonProperty("opted-out-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? OptedOutAtRound { get; set; }


    }

    /// <summary>AssetParams specifies the parameters for an asset.
    /// <br/>
    /// <br/>\[apar\] when part of an AssetConfig transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/asset.go : AssetParams</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AssetParams
    {
        /// <summary>\[c\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.</summary>
        [Newtonsoft.Json.JsonProperty("clawback", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Clawback { get; set; }

        /// <summary>The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.</summary>
        [Newtonsoft.Json.JsonProperty("creator")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Creator { get; set; }

        /// <summary>\[dc\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).</summary>
        [Newtonsoft.Json.JsonProperty("decimals")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 19)]
        public int Decimals { get; set; }

        /// <summary>\[df\] Whether holdings of this asset are frozen by default.</summary>
        [Newtonsoft.Json.JsonProperty("default-frozen", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DefaultFrozen { get; set; }

        /// <summary>\[f\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.</summary>
        [Newtonsoft.Json.JsonProperty("freeze", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Freeze { get; set; }

        /// <summary>\[m\] Address of account used to manage the keys of this asset and to destroy it.</summary>
        [Newtonsoft.Json.JsonProperty("manager", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manager { get; set; }

        /// <summary>\[am\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.</summary>
        [Newtonsoft.Json.JsonProperty("metadata-hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] MetadataHash { get; set; }

        /// <summary>\[an\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Base64 encoded name of this asset, as supplied by the creator.</summary>
        [Newtonsoft.Json.JsonProperty("name-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] NameB64 { get; set; }

        /// <summary>\[r\] Address of account holding reserve (non-minted) units of this asset.</summary>
        [Newtonsoft.Json.JsonProperty("reserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reserve { get; set; }

        /// <summary>\[t\] The total number of units of this asset.</summary>
        [Newtonsoft.Json.JsonProperty("total")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Total { get; set; }

        /// <summary>\[un\] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("unit-name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UnitName { get; set; }

        /// <summary>Base64 encoded name of a unit of this asset, as supplied by the creator.</summary>
        [Newtonsoft.Json.JsonProperty("unit-name-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] UnitNameB64 { get; set; }

        /// <summary>\[au\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>Base64 encoded URL where more information about the asset can be retrieved.</summary>
        [Newtonsoft.Json.JsonProperty("url-b64", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] UrlB64 { get; set; }


    }

    /// <summary>Block information.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/bookkeeping/block.go : Block</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Block
    {
        /// <summary>\[gh\] hash to which this block belongs.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-hash")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] GenesisHash { get; set; }

        /// <summary>\[gen\] ID to which this block belongs.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-id")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GenesisId { get; set; }

        /// <summary>\[prev\] Previous block hash.</summary>
        [Newtonsoft.Json.JsonProperty("previous-block-hash")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] PreviousBlockHash { get; set; }

        [Newtonsoft.Json.JsonProperty("rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BlockRewards Rewards { get; set; }

        /// <summary>\[rnd\] Current round on which this block was appended to the chain.</summary>
        [Newtonsoft.Json.JsonProperty("round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Round { get; set; }

        /// <summary>\[seed\] Sortition seed.</summary>
        [Newtonsoft.Json.JsonProperty("seed")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Seed { get; set; }

        /// <summary>\[ts\] Block creation timestamp in seconds since eposh</summary>
        [Newtonsoft.Json.JsonProperty("timestamp")] //, Required = Newtonsoft.Json.Required.Always)]
        public int Timestamp { get; set; }

        /// <summary>\[txns\] list of transactions corresponding to a given round.</summary>
        [Newtonsoft.Json.JsonProperty("transactions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Transaction> Transactions { get; set; }

        /// <summary>\[txn\] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.</summary>
        [Newtonsoft.Json.JsonProperty("transactions-root")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] TransactionsRoot { get; set; }

        /// <summary>\[tc\] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.
        /// <br/>
        /// <br/>Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).</summary>
        [Newtonsoft.Json.JsonProperty("txn-counter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TxnCounter { get; set; }

        [Newtonsoft.Json.JsonProperty("upgrade-state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BlockUpgradeState UpgradeState { get; set; }

        [Newtonsoft.Json.JsonProperty("upgrade-vote", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BlockUpgradeVote UpgradeVote { get; set; }


    }

    /// <summary>Fields relating to rewards,</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BlockRewards
    {
        /// <summary>\[fees\] accepts transaction fees, it can only spend to the incentive pool.</summary>
        [Newtonsoft.Json.JsonProperty("fee-sink")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeeSink { get; set; }

        /// <summary>\[rwcalr\] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.</summary>
        [Newtonsoft.Json.JsonProperty("rewards-calculation-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong RewardsCalculationRound { get; set; }

        /// <summary>\[earn\] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.</summary>
        [Newtonsoft.Json.JsonProperty("rewards-level")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong RewardsLevel { get; set; }

        /// <summary>\[rwd\] accepts periodic injections from the fee-sink and continually redistributes them as rewards.</summary>
        [Newtonsoft.Json.JsonProperty("rewards-pool")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RewardsPool { get; set; }

        /// <summary>\[rate\] Number of new MicroAlgos added to the participation stake from rewards at the next round.</summary>
        [Newtonsoft.Json.JsonProperty("rewards-rate")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong RewardsRate { get; set; }

        /// <summary>\[frac\] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.</summary>
        [Newtonsoft.Json.JsonProperty("rewards-residue")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong RewardsResidue { get; set; }


    }

    /// <summary>Fields relating to a protocol upgrade.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BlockUpgradeState
    {
        /// <summary>\[proto\] The current protocol version.</summary>
        [Newtonsoft.Json.JsonProperty("current-protocol")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CurrentProtocol { get; set; }

        /// <summary>\[nextproto\] The next proposed protocol version.</summary>
        [Newtonsoft.Json.JsonProperty("next-protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextProtocol { get; set; }

        /// <summary>\[nextyes\] Number of blocks which approved the protocol upgrade.</summary>
        [Newtonsoft.Json.JsonProperty("next-protocol-approvals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NextProtocolApprovals { get; set; }

        /// <summary>\[nextswitch\] Round on which the protocol upgrade will take effect.</summary>
        [Newtonsoft.Json.JsonProperty("next-protocol-switch-on", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NextProtocolSwitchOn { get; set; }

        /// <summary>\[nextbefore\] Deadline round for this protocol upgrade (No votes will be consider after this round).</summary>
        [Newtonsoft.Json.JsonProperty("next-protocol-vote-before", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? NextProtocolVoteBefore { get; set; }


    }

    /// <summary>Fields relating to voting for a protocol upgrade.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BlockUpgradeVote
    {
        /// <summary>\[upgradeyes\] Indicates a yes vote for the current proposal.</summary>
        [Newtonsoft.Json.JsonProperty("upgrade-approve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpgradeApprove { get; set; }

        /// <summary>\[upgradedelay\] Indicates the time between acceptance and execution.</summary>
        [Newtonsoft.Json.JsonProperty("upgrade-delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UpgradeDelay { get; set; }

        /// <summary>\[upgradeprop\] Indicates a proposed upgrade.</summary>
        [Newtonsoft.Json.JsonProperty("upgrade-propose", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UpgradePropose { get; set; }


    }

    /// <summary>A health check response.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class HealthCheck
    {
        /// <summary>Current version.</summary>
        [Newtonsoft.Json.JsonProperty("version")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Round { get; set; }

        [Newtonsoft.Json.JsonProperty("is-migrating")] //, Required = Newtonsoft.Json.Required.Always)]
        public bool IsMigrating { get; set; }

        [Newtonsoft.Json.JsonProperty("db-available")] //, Required = Newtonsoft.Json.Required.Always)]
        public bool DbAvailable { get; set; }

        [Newtonsoft.Json.JsonProperty("message")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Errors { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static HealthCheck FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<HealthCheck>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }
    }

    /// <summary>A simplified version of AssetHolding </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MiniAssetHolding
    {
        [Newtonsoft.Json.JsonProperty("address")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        [Newtonsoft.Json.JsonProperty("amount")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        [Newtonsoft.Json.JsonProperty("is-frozen")] //, Required = Newtonsoft.Json.Required.Always)]
        public bool IsFrozen { get; set; }

        /// <summary>Whether or not this asset holding is currently deleted from its account.</summary>
        [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deleted { get; set; }

        /// <summary>Round during which the account opted into the asset.</summary>
        [Newtonsoft.Json.JsonProperty("opted-in-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? OptedInAtRound { get; set; }

        /// <summary>Round during which the account opted out of the asset.</summary>
        [Newtonsoft.Json.JsonProperty("opted-out-at-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? OptedOutAtRound { get; set; }


    }

    /// <summary>\[apan\] defines the what additional actions occur with the transaction.
    /// <br/>
    /// <br/>Valid types:
    /// <br/>* noop
    /// <br/>* optin
    /// <br/>* closeout
    /// <br/>* clear
    /// <br/>* update
    /// <br/>* update
    /// <br/>* delete</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OnCompletion
    {
        [System.Runtime.Serialization.EnumMember(Value = @"noop")]
        Noop = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"optin")]
        Optin = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"closeout")]
        Closeout = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"clear")]
        Clear = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"update")]
        Update = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"delete")]
        Delete = 5,

    }

    /// <summary>Application state delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class StateDelta : System.Collections.ObjectModel.Collection<EvalDeltaKeyValue>
    {

    }

    /// <summary>Application state delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AccountStateDelta
    {
        [Newtonsoft.Json.JsonProperty("address")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        [Newtonsoft.Json.JsonProperty("delta")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StateDelta Delta { get; set; } = new StateDelta();


    }

    /// <summary>Key-value pairs for StateDelta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvalDeltaKeyValue
    {
        [Newtonsoft.Json.JsonProperty("key")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EvalDelta Value { get; set; } = new EvalDelta();


    }

    /// <summary>Represents a TEAL value delta.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvalDelta
    {
        /// <summary>\[at\] delta action.</summary>
        [Newtonsoft.Json.JsonProperty("action")] //, Required = Newtonsoft.Json.Required.Always)]
        public int Action { get; set; }

        /// <summary>\[bs\] bytes value.</summary>
        [Newtonsoft.Json.JsonProperty("bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bytes { get; set; }

        /// <summary>\[ui\] uint value.</summary>
        [Newtonsoft.Json.JsonProperty("uint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? Uint { get; set; }


    }


    /// <summary>Represents a \[apls\] local-state or \[apgs\] global-state schema. These schemas determine how much storage may be used in a local-state or global-state for an application. The more space used, the larger minimum balance must be maintained in the account holding the data.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    [JsonObject]
    public partial class StateSchema : IEquatable<StateSchema>, IValidatableObject
    {
        public StateSchema(ulong? numUint = 0, ulong? numByteSlice = 0)
        {
            // to ensure "numByteSlice" is required (not null)
            if (numByteSlice == null)
            {
                //throw new InvalidDataException("numByteSlice is a required property for StateSchema and cannot be null");
            }
            else
            {
                this.NumByteSlice = numByteSlice;
            }
            // to ensure "numUint" is required (not null)
            if (numUint == null)
            {
                //throw new InvalidDataException("numUint is a required property for StateSchema and cannot be null");
            }
            else
            {
                this.NumUint = numUint;
            }
        }
        /// <summary>Maximum number of TEAL uints that may be stored in the key/value store.</summary>
        [Newtonsoft.Json.JsonProperty("nui", DefaultValueHandling = DefaultValueHandling.Ignore)] //, Required = Newtonsoft.Json.Required.Always)]
        [DefaultValue(0)]
        public ulong? NumUint { get; set; }

        /// <summary>Maximum number of TEAL byte slices that may be stored in the key/value store.</summary>
        [Newtonsoft.Json.JsonProperty("nbs", DefaultValueHandling = DefaultValueHandling.Ignore)] //, Required = Newtonsoft.Json.Required.Always)]
        [DefaultValue(0)]
        public ulong? NumByteSlice { get; set; }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StateSchema);
        }

        /// <summary>
        /// Returns true if StateSchema instances are equal
        /// </summary>
        /// <param name="input">Instance of StateSchema to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StateSchema input)
        {
            if (input == null)
                return false;

            return
                (
                    this.NumByteSlice == input.NumByteSlice ||
                    (this.NumByteSlice != null &&
                    this.NumByteSlice.Equals(input.NumByteSlice))
                ) &&
                (
                    this.NumUint == input.NumUint ||
                    (this.NumUint != null &&
                    this.NumUint.Equals(input.NumUint))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.NumByteSlice != null)
                    hashCode = hashCode * 59 + this.NumByteSlice.GetHashCode();
                if (this.NumUint != null)
                    hashCode = hashCode * 59 + this.NumUint.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }

    }

    /// <summary>Contains all fields common to all transactions and serves as an envelope to all transactions type. Represents both regular and inner transactions.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/signedtxn.go : SignedTxn
    /// <br/>data/transactions/transaction.go : Transaction
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Transaction
    {
        [Newtonsoft.Json.JsonProperty("application-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionApplication ApplicationTransaction { get; set; }

        [Newtonsoft.Json.JsonProperty("asset-config-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionAssetConfig AssetConfigTransaction { get; set; }

        [Newtonsoft.Json.JsonProperty("asset-freeze-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionAssetFreeze AssetFreezeTransaction { get; set; }

        [Newtonsoft.Json.JsonProperty("asset-transfer-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionAssetTransfer AssetTransferTransaction { get; set; }

        /// <summary>\[sgnr\] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.</summary>
        [Newtonsoft.Json.JsonProperty("auth-addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthAddr { get; set; }

        /// <summary>\[rc\] rewards applied to close-remainder-to account.</summary>
        [Newtonsoft.Json.JsonProperty("close-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CloseRewards { get; set; }

        /// <summary>\[ca\] closing amount for transaction.</summary>
        [Newtonsoft.Json.JsonProperty("closing-amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ClosingAmount { get; set; }

        /// <summary>Round when the transaction was confirmed.</summary>
        [Newtonsoft.Json.JsonProperty("confirmed-round", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ConfirmedRound { get; set; }

        /// <summary>Specifies an application index (ID) if an application was created with this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("created-application-index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CreatedApplicationIndex { get; set; }

        /// <summary>Specifies an asset index (ID) if an asset was created with this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("created-asset-index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CreatedAssetIndex { get; set; }

        /// <summary>\[fee\] Transaction fee.</summary>
        [Newtonsoft.Json.JsonProperty("fee")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Fee { get; set; }

        /// <summary>\[fv\] First valid round for this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("first-valid")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong FirstValid { get; set; }

        /// <summary>\[gh\] Hash of genesis block.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] GenesisHash { get; set; }

        /// <summary>\[gen\] genesis block ID.</summary>
        [Newtonsoft.Json.JsonProperty("genesis-id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenesisId { get; set; }

        /// <summary>\[grp\] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Group { get; set; }

        /// <summary>Transaction ID</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>Offset into the round where this transaction was confirmed.</summary>
        [Newtonsoft.Json.JsonProperty("intra-round-offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? IntraRoundOffset { get; set; }

        [Newtonsoft.Json.JsonProperty("keyreg-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionKeyreg KeyregTransaction { get; set; }

        /// <summary>\[lv\] Last valid round for this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("last-valid")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong LastValid { get; set; }

        /// <summary>\[lx\] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.</summary>
        [Newtonsoft.Json.JsonProperty("lease", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Lease { get; set; }

        /// <summary>\[note\] Free form data.</summary>
        [Newtonsoft.Json.JsonProperty("note", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Note { get; set; }

        [Newtonsoft.Json.JsonProperty("payment-transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionPayment PaymentTransaction { get; set; }

        /// <summary>\[rr\] rewards applied to receiver account.</summary>
        [Newtonsoft.Json.JsonProperty("receiver-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ReceiverRewards { get; set; }

        /// <summary>\[rekey\] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.</summary>
        [Newtonsoft.Json.JsonProperty("rekey-to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RekeyTo { get; set; }

        /// <summary>Time when the block this transaction is in was confirmed.</summary>
        [Newtonsoft.Json.JsonProperty("round-time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RoundTime { get; set; }

        /// <summary>\[snd\] Sender's address.</summary>
        [Newtonsoft.Json.JsonProperty("sender")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Sender { get; set; }

        /// <summary>\[rs\] rewards applied to sender account.</summary>
        [Newtonsoft.Json.JsonProperty("sender-rewards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SenderRewards { get; set; }

        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionSignature Signature { get; set; }

        /// <summary>\[type\] Indicates what type of transaction this is. Different types have different fields.
        /// <br/>
        /// <br/>Valid types, and where their fields are stored:
        /// <br/>* \[pay\] payment-transaction
        /// <br/>* \[keyreg\] keyreg-transaction
        /// <br/>* \[acfg\] asset-config-transaction
        /// <br/>* \[axfer\] asset-transfer-transaction
        /// <br/>* \[afrz\] asset-freeze-transaction
        /// <br/>* \[appl\] application-transaction</summary>
        [Newtonsoft.Json.JsonProperty("tx-type")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TransactionTxType TxType { get; set; }

        /// <summary>\[ld\] Local state key/value changes for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("local-state-delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AccountStateDelta> LocalStateDelta { get; set; }

        /// <summary>\[gd\] Global state key/value changes for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("global-state-delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StateDelta GlobalStateDelta { get; set; }

        /// <summary>\[lg\] Logs for the application being executed by this transaction.</summary>
        [Newtonsoft.Json.JsonProperty("logs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Logs { get; set; }

        /// <summary>Inner transactions produced by application execution.</summary>
        [Newtonsoft.Json.JsonProperty("inner-txns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Transaction> InnerTxns { get; set; }


    }

    /// <summary>Fields for application transactions.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/application.go : ApplicationCallTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionApplication
    {
        /// <summary>\[apid\] ID of the application being configured or empty if creating.</summary>
        [Newtonsoft.Json.JsonProperty("application-id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong ApplicationId { get; set; }

        [Newtonsoft.Json.JsonProperty("on-completion")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OnCompletion OnCompletion { get; set; }

        /// <summary>\[apaa\] transaction specific arguments accessed from the application's approval-program and clear-state-program.</summary>
        [Newtonsoft.Json.JsonProperty("application-args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ApplicationArgs { get; set; }

        /// <summary>\[apat\] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.</summary>
        [Newtonsoft.Json.JsonProperty("accounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Accounts { get; set; }

        /// <summary>\[apfa\] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.</summary>
        [Newtonsoft.Json.JsonProperty("foreign-apps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ulong> ForeignApps { get; set; }

        /// <summary>\[apas\] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.</summary>
        [Newtonsoft.Json.JsonProperty("foreign-assets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ulong> ForeignAssets { get; set; }

        [Newtonsoft.Json.JsonProperty("local-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StateSchema LocalStateSchema { get; set; }

        [Newtonsoft.Json.JsonProperty("global-state-schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StateSchema GlobalStateSchema { get; set; }

        /// <summary>\[apap\] Logic executed for every application transaction, except when on-completion is set to "clear". It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("approval-program", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] ApprovalProgram { get; set; }

        /// <summary>\[apsu\] Logic executed for application transactions with on-completion set to "clear". It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("clear-state-program", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] ClearStateProgram { get; set; }

        /// <summary>\[epp\] specifies the additional app program len requested in pages.</summary>
        [Newtonsoft.Json.JsonProperty("extra-program-pages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ExtraProgramPages { get; set; }


    }

    /// <summary>Fields for asset allocation, re-configuration, and destruction.
    /// <br/>
    /// <br/>
    /// <br/>A zero value for asset-id indicates asset creation.
    /// <br/>A zero value for the params indicates asset destruction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/asset.go : AssetConfigTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionAssetConfig
    {
        /// <summary>\[xaid\] ID of the asset being configured or empty if creating.</summary>
        [Newtonsoft.Json.JsonProperty("asset-id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AssetId { get; set; }

        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AssetParams Params { get; set; }


    }

    /// <summary>Fields for an asset freeze transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/asset.go : AssetFreezeTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionAssetFreeze
    {
        /// <summary>\[fadd\] Address of the account whose asset is being frozen or thawed.</summary>
        [Newtonsoft.Json.JsonProperty("address")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>\[faid\] ID of the asset being frozen or thawed.</summary>
        [Newtonsoft.Json.JsonProperty("asset-id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong AssetId { get; set; }

        /// <summary>\[afrz\] The new freeze status.</summary>
        [Newtonsoft.Json.JsonProperty("new-freeze-status")] //, Required = Newtonsoft.Json.Required.Always)]
        public bool NewFreezeStatus { get; set; }


    }

    /// <summary>Fields for an asset transfer transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/asset.go : AssetTransferTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionAssetTransfer
    {
        /// <summary>\[aamt\] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.</summary>
        [Newtonsoft.Json.JsonProperty("amount")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>\[xaid\] ID of the asset being transferred.</summary>
        [Newtonsoft.Json.JsonProperty("asset-id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong AssetId { get; set; }

        /// <summary>Number of assets transfered to the close-to account as part of the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("close-amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ulong? CloseAmount { get; set; }

        /// <summary>\[aclose\] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.</summary>
        [Newtonsoft.Json.JsonProperty("close-to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CloseTo { get; set; }

        /// <summary>\[arcv\] Recipient address of the transfer.</summary>
        [Newtonsoft.Json.JsonProperty("receiver")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Receiver { get; set; }

        /// <summary>\[asnd\] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.</summary>
        [Newtonsoft.Json.JsonProperty("sender", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sender { get; set; }


    }

    /// <summary>Fields for a keyreg transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/keyreg.go : KeyregTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionKeyreg
    {
        /// <summary>\[nonpart\] Mark the account as participating or non-participating.</summary>
        [Newtonsoft.Json.JsonProperty("non-participation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NonParticipation { get; set; }

        /// <summary>\[selkey\] Public key used with the Verified Random Function (VRF) result during committee selection.</summary>
        [Newtonsoft.Json.JsonProperty("selection-participation-key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] SelectionParticipationKey { get; set; }

        /// <summary>\[votefst\] First round this participation key is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-first-valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? VoteFirstValid { get; set; }

        /// <summary>\[votekd\] Number of subkeys in each batch of participation keys.</summary>
        [Newtonsoft.Json.JsonProperty("vote-key-dilution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? VoteKeyDilution { get; set; }

        /// <summary>\[votelst\] Last round this participation key is valid.</summary>
        [Newtonsoft.Json.JsonProperty("vote-last-valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? VoteLastValid { get; set; }

        /// <summary>\[votekey\] Participation public key used in key registration transactions.</summary>
        [Newtonsoft.Json.JsonProperty("vote-participation-key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] VoteParticipationKey { get; set; }


    }

    /// <summary>Fields for a payment transaction.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/payment.go : PaymentTxnFields</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionPayment
    {
        /// <summary>\[amt\] number of MicroAlgos intended to be transferred.</summary>
        [Newtonsoft.Json.JsonProperty("amount")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong Amount { get; set; }

        /// <summary>Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.</summary>
        [Newtonsoft.Json.JsonProperty("close-amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CloseAmount { get; set; }

        /// <summary>\[close\] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.</summary>
        [Newtonsoft.Json.JsonProperty("close-remainder-to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CloseRemainderTo { get; set; }

        /// <summary>\[rcv\] receiver's address.</summary>
        [Newtonsoft.Json.JsonProperty("receiver")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Receiver { get; set; }


    }

    /// <summary>Validation signature associated with some data. Only one of the signatures should be provided.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionSignature
    {
        [Newtonsoft.Json.JsonProperty("logicsig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionSignatureLogicsig Logicsig { get; set; }

        [Newtonsoft.Json.JsonProperty("multisig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionSignatureMultisig Multisig { get; set; }

        /// <summary>\[sig\] Standard ed25519 signature.</summary>
        [Newtonsoft.Json.JsonProperty("sig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Sig { get; set; }


    }

    /// <summary>\[lsig\] Programatic transaction signature.
    /// <br/>
    /// <br/>Definition:
    /// <br/>data/transactions/logicsig.go</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionSignatureLogicsig
    {
        /// <summary>\[arg\] Logic arguments, base64 encoded.</summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>\[l\] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.</summary>
        [Newtonsoft.Json.JsonProperty("logic")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Logic { get; set; }

        [Newtonsoft.Json.JsonProperty("multisig-signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TransactionSignatureMultisig MultisigSignature { get; set; }

        /// <summary>\[sig\] ed25519 signature.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Signature { get; set; }


    }

    /// <summary>\[msig\] structure holding multiple subsignatures.
    /// <br/>
    /// <br/>Definition:
    /// <br/>crypto/multisig.go : MultisigSig</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionSignatureMultisig
    {
        /// <summary>\[subsig\] holds pairs of public key and signatures.</summary>
        [Newtonsoft.Json.JsonProperty("subsignature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionSignatureMultisigSubsignature> Subsignature { get; set; }

        /// <summary>\[thr\]</summary>
        [Newtonsoft.Json.JsonProperty("threshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Threshold { get; set; }

        /// <summary>\[v\]</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Version { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TransactionSignatureMultisigSubsignature
    {
        /// <summary>\[pk\]</summary>
        [Newtonsoft.Json.JsonProperty("public-key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] PublicKey { get; set; }

        /// <summary>\[s\]</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Signature { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum TxType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pay")]
        Pay = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"keyreg")]
        Keyreg = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"acfg")]
        Acfg = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"axfer")]
        Axfer = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"afrz")]
        Afrz = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"appl")]
        Appl = 5,

    }

    /// <summary>SigType filters just results using the specified type of signature:
    /// <br/>* sig - Standard
    /// <br/>* msig - MultiSig
    /// <br/>* lsig - LogicSig</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SigType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"sig")]
        Sig = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"msig")]
        Msig = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lsig")]
        Lsig = 2,

    }

    /// <summary>Combine with the address parameter to define what type of address to search for.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum AddressRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"sender")]
        Sender = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"receiver")]
        Receiver = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"freeze-target")]
        FreezeTarget = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response
    {
        [Newtonsoft.Json.JsonProperty("accounts")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Account> Accounts { get; set; } = new System.Collections.ObjectModel.Collection<Account>();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response2
    {
        [Newtonsoft.Json.JsonProperty("applications")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Application> Applications { get; set; } = new System.Collections.ObjectModel.Collection<Application>();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response2>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response3
    {
        [Newtonsoft.Json.JsonProperty("assets")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Asset> Assets { get; set; } = new System.Collections.ObjectModel.Collection<Asset>();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response3>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response4
    {
        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }

        [Newtonsoft.Json.JsonProperty("transactions")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Transaction> Transactions { get; set; } = new System.Collections.ObjectModel.Collection<Transaction>();

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response4>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response5
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("message")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }


    }



    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response6
    {
        [Newtonsoft.Json.JsonProperty("account")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Account Account { get; set; } = new Account();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response6>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response7
    {
        [Newtonsoft.Json.JsonProperty("application", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Application Application { get; set; }

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response7>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response8
    {
        /// <summary>\[appidx\] application index.</summary>
        [Newtonsoft.Json.JsonProperty("application-id")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong ApplicationId { get; set; }

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }

        [Newtonsoft.Json.JsonProperty("log-data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApplicationLogData> LogData { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response9
    {
        [Newtonsoft.Json.JsonProperty("asset")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Asset Asset { get; set; } = new Asset();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());
        }

        public static Response9 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Response9>(data, new Newtonsoft.Json.JsonSerializerSettings());
        }



    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response10
    {
        [Newtonsoft.Json.JsonProperty("balances")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<MiniAssetHolding> Balances { get; set; } = new System.Collections.ObjectModel.Collection<MiniAssetHolding>();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }

        /// <summary>Used for pagination, when making another request provide this token with the next parameter.</summary>
        [Newtonsoft.Json.JsonProperty("next-token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextToken { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Response11
    {
        [Newtonsoft.Json.JsonProperty("transaction")] //, Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Transaction Transaction { get; set; } = new Transaction();

        /// <summary>Round at which the results were computed.</summary>
        [Newtonsoft.Json.JsonProperty("current-round")] //, Required = Newtonsoft.Json.Required.Always)]
        public ulong CurrentRound { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum AccountSigType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"sig")]
        Sig = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"msig")]
        Msig = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lsig")]
        Lsig = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum TransactionTxType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"pay")]
        Pay = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"keyreg")]
        Keyreg = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"acfg")]
        Acfg = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"axfer")]
        Axfer = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"afrz")]
        Afrz = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"appl")]
        Appl = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.14.5.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108
#pragma warning restore 3016