/* 
 * Algod REST API.
 *
 * API Endpoint for AlgoD Operations.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = Algorand.Client.SwaggerDateConverter;

namespace Algorand.Algod.Model
{
    /// <summary>
    /// Block contains a block information
    /// </summary>
    [DataContract]
        public partial class Block :  IEquatable<Block>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Block" /> class.
        /// </summary>
        /// <param name="currentProtocol">CurrentProtocol is a string that represents the current protocol (required).</param>
        /// <param name="frac">The number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round..</param>
        /// <param name="hash">Hash is the current block hash (required).</param>
        /// <param name="nextProtocol">NextProtocol is a string that represents the next proposed protocol (required).</param>
        /// <param name="nextProtocolApprovals">NextProtocolApprovals is the number of blocks which approved the protocol upgrade (required).</param>
        /// <param name="nextProtocolSwitchOn">NextProtocolSwitchOn is the round on which the protocol upgrade will take effect (required).</param>
        /// <param name="nextProtocolVoteBefore">NextProtocolVoteBefore is the deadline round for this protocol upgrade (No votes will be consider after this round) (required).</param>
        /// <param name="period">Period is the period on which the block was confirmed (required).</param>
        /// <param name="previousBlockHash">PreviousBlockHash is the previous block hash (required).</param>
        /// <param name="proposer">Proposer is the address of this block proposer (required).</param>
        /// <param name="rate">The number of new MicroAlgos added to the participation stake from rewards at the next round..</param>
        /// <param name="reward">RewardsLevel specifies how many rewards, in MicroAlgos, have been distributed to each config.Protocol.RewardUnit of MicroAlgos since genesis..</param>
        /// <param name="round">Round is the current round on which this block was appended to the chain (required).</param>
        /// <param name="seed">Seed is the sortition seed (required).</param>
        /// <param name="timestamp">TimeStamp in seconds since epoch (required).</param>
        /// <param name="txnRoot">TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it&#x27;s the root of a merkle tree whose leaves are the block&#x27;s Txids, in lexicographic order. For the empty block, it&#x27;s 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot. (required).</param>
        /// <param name="txns">txns.</param>
        /// <param name="upgradeApprove">UpgradeApprove indicates a yes vote for the current proposal (required).</param>
        /// <param name="upgradePropose">UpgradePropose indicates a proposed upgrade (required).</param>
        public Block(string currentProtocol = default(string), ulong? frac = default(ulong?), string hash = default(string), string nextProtocol = default(string), ulong? nextProtocolApprovals = default(ulong?), ulong? nextProtocolSwitchOn = default(ulong?), ulong? nextProtocolVoteBefore = default(ulong?), ulong? period = default(ulong?), string previousBlockHash = default(string), string proposer = default(string), ulong? rate = default(ulong?), ulong? reward = default(ulong?), ulong? round = default(ulong?), string seed = default(string), long? timestamp = default(long?), string txnRoot = default(string), TransactionList txns = default(TransactionList), bool? upgradeApprove = default(bool?), string upgradePropose = default(string))
        {
            // to ensure "currentProtocol" is required (not null)
            if (currentProtocol == null)
            {
                throw new InvalidDataException("currentProtocol is a required property for Block and cannot be null");
            }
            else
            {
                this.CurrentProtocol = currentProtocol;
            }
            // to ensure "hash" is required (not null)
            if (hash == null)
            {
                throw new InvalidDataException("hash is a required property for Block and cannot be null");
            }
            else
            {
                this.Hash = hash;
            }
            // to ensure "nextProtocol" is required (not null)
            if (nextProtocol == null)
            {
                throw new InvalidDataException("nextProtocol is a required property for Block and cannot be null");
            }
            else
            {
                this.NextProtocol = nextProtocol;
            }
            // to ensure "nextProtocolApprovals" is required (not null)
            if (nextProtocolApprovals == null)
            {
                throw new InvalidDataException("nextProtocolApprovals is a required property for Block and cannot be null");
            }
            else
            {
                this.NextProtocolApprovals = nextProtocolApprovals;
            }
            // to ensure "nextProtocolSwitchOn" is required (not null)
            if (nextProtocolSwitchOn == null)
            {
                throw new InvalidDataException("nextProtocolSwitchOn is a required property for Block and cannot be null");
            }
            else
            {
                this.NextProtocolSwitchOn = nextProtocolSwitchOn;
            }
            // to ensure "nextProtocolVoteBefore" is required (not null)
            if (nextProtocolVoteBefore == null)
            {
                throw new InvalidDataException("nextProtocolVoteBefore is a required property for Block and cannot be null");
            }
            else
            {
                this.NextProtocolVoteBefore = nextProtocolVoteBefore;
            }
            // to ensure "period" is required (not null)
            if (period == null)
            {
                throw new InvalidDataException("period is a required property for Block and cannot be null");
            }
            else
            {
                this.Period = period;
            }
            // to ensure "previousBlockHash" is required (not null)
            if (previousBlockHash == null)
            {
                throw new InvalidDataException("previousBlockHash is a required property for Block and cannot be null");
            }
            else
            {
                this.PreviousBlockHash = previousBlockHash;
            }
            // to ensure "proposer" is required (not null)
            if (proposer == null)
            {
                throw new InvalidDataException("proposer is a required property for Block and cannot be null");
            }
            else
            {
                this.Proposer = proposer;
            }
            // to ensure "round" is required (not null)
            if (round == null)
            {
                throw new InvalidDataException("round is a required property for Block and cannot be null");
            }
            else
            {
                this.Round = round;
            }
            // to ensure "seed" is required (not null)
            if (seed == null)
            {
                throw new InvalidDataException("seed is a required property for Block and cannot be null");
            }
            else
            {
                this.Seed = seed;
            }
            // to ensure "timestamp" is required (not null)
            if (timestamp == null)
            {
                throw new InvalidDataException("timestamp is a required property for Block and cannot be null");
            }
            else
            {
                this.Timestamp = timestamp;
            }
            // to ensure "txnRoot" is required (not null)
            if (txnRoot == null)
            {
                throw new InvalidDataException("txnRoot is a required property for Block and cannot be null");
            }
            else
            {
                this.TxnRoot = txnRoot;
            }
            // to ensure "upgradeApprove" is required (not null)
            if (upgradeApprove == null)
            {
                throw new InvalidDataException("upgradeApprove is a required property for Block and cannot be null");
            }
            else
            {
                this.UpgradeApprove = upgradeApprove;
            }
            // to ensure "upgradePropose" is required (not null)
            if (upgradePropose == null)
            {
                throw new InvalidDataException("upgradePropose is a required property for Block and cannot be null");
            }
            else
            {
                this.UpgradePropose = upgradePropose;
            }
            this.Frac = frac;
            this.Rate = rate;
            this.Reward = reward;
            this.Txns = txns;
        }
        
        /// <summary>
        /// CurrentProtocol is a string that represents the current protocol
        /// </summary>
        /// <value>CurrentProtocol is a string that represents the current protocol</value>
        [DataMember(Name="currentProtocol", EmitDefaultValue=false)]
        public string CurrentProtocol { get; set; }

        /// <summary>
        /// The number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
        /// </summary>
        /// <value>The number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.</value>
        [DataMember(Name="frac", EmitDefaultValue=false)]
        public ulong? Frac { get; set; }

        /// <summary>
        /// Hash is the current block hash
        /// </summary>
        /// <value>Hash is the current block hash</value>
        [DataMember(Name="hash", EmitDefaultValue=false)]
        public string Hash { get; set; }

        /// <summary>
        /// NextProtocol is a string that represents the next proposed protocol
        /// </summary>
        /// <value>NextProtocol is a string that represents the next proposed protocol</value>
        [DataMember(Name="nextProtocol", EmitDefaultValue=false)]
        public string NextProtocol { get; set; }

        /// <summary>
        /// NextProtocolApprovals is the number of blocks which approved the protocol upgrade
        /// </summary>
        /// <value>NextProtocolApprovals is the number of blocks which approved the protocol upgrade</value>
        [DataMember(Name="nextProtocolApprovals", EmitDefaultValue=false)]
        public ulong? NextProtocolApprovals { get; set; }

        /// <summary>
        /// NextProtocolSwitchOn is the round on which the protocol upgrade will take effect
        /// </summary>
        /// <value>NextProtocolSwitchOn is the round on which the protocol upgrade will take effect</value>
        [DataMember(Name="nextProtocolSwitchOn", EmitDefaultValue=false)]
        public ulong? NextProtocolSwitchOn { get; set; }

        /// <summary>
        /// NextProtocolVoteBefore is the deadline round for this protocol upgrade (No votes will be consider after this round)
        /// </summary>
        /// <value>NextProtocolVoteBefore is the deadline round for this protocol upgrade (No votes will be consider after this round)</value>
        [DataMember(Name="nextProtocolVoteBefore", EmitDefaultValue=false)]
        public ulong? NextProtocolVoteBefore { get; set; }

        /// <summary>
        /// Period is the period on which the block was confirmed
        /// </summary>
        /// <value>Period is the period on which the block was confirmed</value>
        [DataMember(Name="period", EmitDefaultValue=false)]
        public ulong? Period { get; set; }

        /// <summary>
        /// PreviousBlockHash is the previous block hash
        /// </summary>
        /// <value>PreviousBlockHash is the previous block hash</value>
        [DataMember(Name="previousBlockHash", EmitDefaultValue=false)]
        public string PreviousBlockHash { get; set; }

        /// <summary>
        /// Proposer is the address of this block proposer
        /// </summary>
        /// <value>Proposer is the address of this block proposer</value>
        [DataMember(Name="proposer", EmitDefaultValue=false)]
        public string Proposer { get; set; }

        /// <summary>
        /// The number of new MicroAlgos added to the participation stake from rewards at the next round.
        /// </summary>
        /// <value>The number of new MicroAlgos added to the participation stake from rewards at the next round.</value>
        [DataMember(Name="rate", EmitDefaultValue=false)]
        public ulong? Rate { get; set; }

        /// <summary>
        /// RewardsLevel specifies how many rewards, in MicroAlgos, have been distributed to each config.Protocol.RewardUnit of MicroAlgos since genesis.
        /// </summary>
        /// <value>RewardsLevel specifies how many rewards, in MicroAlgos, have been distributed to each config.Protocol.RewardUnit of MicroAlgos since genesis.</value>
        [DataMember(Name="reward", EmitDefaultValue=false)]
        public ulong? Reward { get; set; }

        /// <summary>
        /// Round is the current round on which this block was appended to the chain
        /// </summary>
        /// <value>Round is the current round on which this block was appended to the chain</value>
        [DataMember(Name="round", EmitDefaultValue=false)]
        public ulong? Round { get; set; }

        /// <summary>
        /// Seed is the sortition seed
        /// </summary>
        /// <value>Seed is the sortition seed</value>
        [DataMember(Name="seed", EmitDefaultValue=false)]
        public string Seed { get; set; }

        /// <summary>
        /// TimeStamp in seconds since epoch
        /// </summary>
        /// <value>TimeStamp in seconds since epoch</value>
        [DataMember(Name="timestamp", EmitDefaultValue=false)]
        public long? Timestamp { get; set; }

        /// <summary>
        /// TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it&#x27;s the root of a merkle tree whose leaves are the block&#x27;s Txids, in lexicographic order. For the empty block, it&#x27;s 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.
        /// </summary>
        /// <value>TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it&#x27;s the root of a merkle tree whose leaves are the block&#x27;s Txids, in lexicographic order. For the empty block, it&#x27;s 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.</value>
        [DataMember(Name="txnRoot", EmitDefaultValue=false)]
        public string TxnRoot { get; set; }

        /// <summary>
        /// Gets or Sets Txns
        /// </summary>
        [DataMember(Name="txns", EmitDefaultValue=false)]
        public TransactionList Txns { get; set; }

        /// <summary>
        /// UpgradeApprove indicates a yes vote for the current proposal
        /// </summary>
        /// <value>UpgradeApprove indicates a yes vote for the current proposal</value>
        [DataMember(Name="upgradeApprove", EmitDefaultValue=false)]
        public bool? UpgradeApprove { get; set; }

        /// <summary>
        /// UpgradePropose indicates a proposed upgrade
        /// </summary>
        /// <value>UpgradePropose indicates a proposed upgrade</value>
        [DataMember(Name="upgradePropose", EmitDefaultValue=false)]
        public string UpgradePropose { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Block {\n");
            sb.Append("  CurrentProtocol: ").Append(CurrentProtocol).Append("\n");
            sb.Append("  Frac: ").Append(Frac).Append("\n");
            sb.Append("  Hash: ").Append(Hash).Append("\n");
            sb.Append("  NextProtocol: ").Append(NextProtocol).Append("\n");
            sb.Append("  NextProtocolApprovals: ").Append(NextProtocolApprovals).Append("\n");
            sb.Append("  NextProtocolSwitchOn: ").Append(NextProtocolSwitchOn).Append("\n");
            sb.Append("  NextProtocolVoteBefore: ").Append(NextProtocolVoteBefore).Append("\n");
            sb.Append("  Period: ").Append(Period).Append("\n");
            sb.Append("  PreviousBlockHash: ").Append(PreviousBlockHash).Append("\n");
            sb.Append("  Proposer: ").Append(Proposer).Append("\n");
            sb.Append("  Rate: ").Append(Rate).Append("\n");
            sb.Append("  Reward: ").Append(Reward).Append("\n");
            sb.Append("  Round: ").Append(Round).Append("\n");
            sb.Append("  Seed: ").Append(Seed).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  TxnRoot: ").Append(TxnRoot).Append("\n");
            sb.Append("  Txns: ").Append(Txns).Append("\n");
            sb.Append("  UpgradeApprove: ").Append(UpgradeApprove).Append("\n");
            sb.Append("  UpgradePropose: ").Append(UpgradePropose).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Block);
        }

        /// <summary>
        /// Returns true if Block instances are equal
        /// </summary>
        /// <param name="input">Instance of Block to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Block input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.CurrentProtocol == input.CurrentProtocol ||
                    (this.CurrentProtocol != null &&
                    this.CurrentProtocol.Equals(input.CurrentProtocol))
                ) && 
                (
                    this.Frac == input.Frac ||
                    (this.Frac != null &&
                    this.Frac.Equals(input.Frac))
                ) && 
                (
                    this.Hash == input.Hash ||
                    (this.Hash != null &&
                    this.Hash.Equals(input.Hash))
                ) && 
                (
                    this.NextProtocol == input.NextProtocol ||
                    (this.NextProtocol != null &&
                    this.NextProtocol.Equals(input.NextProtocol))
                ) && 
                (
                    this.NextProtocolApprovals == input.NextProtocolApprovals ||
                    (this.NextProtocolApprovals != null &&
                    this.NextProtocolApprovals.Equals(input.NextProtocolApprovals))
                ) && 
                (
                    this.NextProtocolSwitchOn == input.NextProtocolSwitchOn ||
                    (this.NextProtocolSwitchOn != null &&
                    this.NextProtocolSwitchOn.Equals(input.NextProtocolSwitchOn))
                ) && 
                (
                    this.NextProtocolVoteBefore == input.NextProtocolVoteBefore ||
                    (this.NextProtocolVoteBefore != null &&
                    this.NextProtocolVoteBefore.Equals(input.NextProtocolVoteBefore))
                ) && 
                (
                    this.Period == input.Period ||
                    (this.Period != null &&
                    this.Period.Equals(input.Period))
                ) && 
                (
                    this.PreviousBlockHash == input.PreviousBlockHash ||
                    (this.PreviousBlockHash != null &&
                    this.PreviousBlockHash.Equals(input.PreviousBlockHash))
                ) && 
                (
                    this.Proposer == input.Proposer ||
                    (this.Proposer != null &&
                    this.Proposer.Equals(input.Proposer))
                ) && 
                (
                    this.Rate == input.Rate ||
                    (this.Rate != null &&
                    this.Rate.Equals(input.Rate))
                ) && 
                (
                    this.Reward == input.Reward ||
                    (this.Reward != null &&
                    this.Reward.Equals(input.Reward))
                ) && 
                (
                    this.Round == input.Round ||
                    (this.Round != null &&
                    this.Round.Equals(input.Round))
                ) && 
                (
                    this.Seed == input.Seed ||
                    (this.Seed != null &&
                    this.Seed.Equals(input.Seed))
                ) && 
                (
                    this.Timestamp == input.Timestamp ||
                    (this.Timestamp != null &&
                    this.Timestamp.Equals(input.Timestamp))
                ) && 
                (
                    this.TxnRoot == input.TxnRoot ||
                    (this.TxnRoot != null &&
                    this.TxnRoot.Equals(input.TxnRoot))
                ) && 
                (
                    this.Txns == input.Txns ||
                    (this.Txns != null &&
                    this.Txns.Equals(input.Txns))
                ) && 
                (
                    this.UpgradeApprove == input.UpgradeApprove ||
                    (this.UpgradeApprove != null &&
                    this.UpgradeApprove.Equals(input.UpgradeApprove))
                ) && 
                (
                    this.UpgradePropose == input.UpgradePropose ||
                    (this.UpgradePropose != null &&
                    this.UpgradePropose.Equals(input.UpgradePropose))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CurrentProtocol != null)
                    hashCode = hashCode * 59 + this.CurrentProtocol.GetHashCode();
                if (this.Frac != null)
                    hashCode = hashCode * 59 + this.Frac.GetHashCode();
                if (this.Hash != null)
                    hashCode = hashCode * 59 + this.Hash.GetHashCode();
                if (this.NextProtocol != null)
                    hashCode = hashCode * 59 + this.NextProtocol.GetHashCode();
                if (this.NextProtocolApprovals != null)
                    hashCode = hashCode * 59 + this.NextProtocolApprovals.GetHashCode();
                if (this.NextProtocolSwitchOn != null)
                    hashCode = hashCode * 59 + this.NextProtocolSwitchOn.GetHashCode();
                if (this.NextProtocolVoteBefore != null)
                    hashCode = hashCode * 59 + this.NextProtocolVoteBefore.GetHashCode();
                if (this.Period != null)
                    hashCode = hashCode * 59 + this.Period.GetHashCode();
                if (this.PreviousBlockHash != null)
                    hashCode = hashCode * 59 + this.PreviousBlockHash.GetHashCode();
                if (this.Proposer != null)
                    hashCode = hashCode * 59 + this.Proposer.GetHashCode();
                if (this.Rate != null)
                    hashCode = hashCode * 59 + this.Rate.GetHashCode();
                if (this.Reward != null)
                    hashCode = hashCode * 59 + this.Reward.GetHashCode();
                if (this.Round != null)
                    hashCode = hashCode * 59 + this.Round.GetHashCode();
                if (this.Seed != null)
                    hashCode = hashCode * 59 + this.Seed.GetHashCode();
                if (this.Timestamp != null)
                    hashCode = hashCode * 59 + this.Timestamp.GetHashCode();
                if (this.TxnRoot != null)
                    hashCode = hashCode * 59 + this.TxnRoot.GetHashCode();
                if (this.Txns != null)
                    hashCode = hashCode * 59 + this.Txns.GetHashCode();
                if (this.UpgradeApprove != null)
                    hashCode = hashCode * 59 + this.UpgradeApprove.GetHashCode();
                if (this.UpgradePropose != null)
                    hashCode = hashCode * 59 + this.UpgradePropose.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
